
# Setup
 This section will guide you how to setup this project

1. Create empty folder structure as on photo 
    ![Folder structure](./Assets/FolderStructure.png "Project folder structure")
2. initiate tempalte`s WebAPI project with the `dotnet new WebAPI` command in the `src/APIServer/API/` folder. This will create a default `.net WebAPI` template containing basic settings that we do not need to write manually like `appsettings.json`, `Startup.cs`, `Programme.cs`, `Properties/launchSettings.json` and `API.csproj`...
3. remove the contents of the `Controllers` folder and remove `WeatherForecast.cs` from the main folder. This file was generated by the template and is not needed for the demo.

## Lunch  WebAPI project
 
The current setup contains an empty WebAPI program. There are several ways to run it.

- By running `dotnet run` or `dotnet watch run` from the `src/APIServer/API/` folder from the command line (terminal). - `Watch` means that the process will monitor your file changes and automatically restart the server when you edit a file. This is helpful in development so you do not have to do this manually after new changes to the code.

- Use your editor VsCode or VsStudio or another... - Note that VSCode uses different lunch settings when you run the application with the debugger attached. (More about this in the section [Environment](#enviroment).
# Understanding init setup

This section explains what has been created with the `dotnet new WebAPI` framework. It is good to understand what is preconfigured.

## AppBuilder

In `Program.cs` the [Default builder](https://github.com/dotnet/aspnetcore/blob/4cbce2fda399775daed8641fa36955db0a97a09b/src/DefaultBuilder/src/WebHost.cs#L156) is used by template to configure your app.

```c#
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder => {
            webBuilder.UseStartup<Startup>();
        });
```

**This happends under the hood:**

1) Enviroment - Default `HostBuilder` is created. It includes code defaults enviroment settings. 
2) Configuration from `appsettings.json` and `appsettings.{enviroment}.json` is loaded and applyed.
3) Loads Enviroment variables (for concrete Enviroment)
4) Configure Logging (Some default preconfigured)
5) Adds service provider - [Dependency injection](https://github.com/dotnet/aspnetcore/blob/4cbce2fda399775daed8641fa36955db0a97a09b/src/Hosting/Hosting/src/GenericHost/GenericWebHostBuilder.cs#L201)  (more about DI under [oficial Docs](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-5.0)).

This is part of the `.NetCore` standard application init process. It preconfigures typical settings for the application. This configuration can be overridden in code or custom builders can be injected with their own configuration steps. For more information, see Official [Microsoft Docs](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-5.0#default).

Configuration is done by calling multiple [providers](https://docs.microsoft.com/en-us/dotnet/core/extensions/configuration-providers). This providers reads key-value pairs using a variety of sources:

- Settings files, as `appsettings.json` (JSON/XML/INI)
- Environment variables as `ASPNETCORE_ENVIRONMENT`
- Azure Key Vault / Azure App Configuration
- Command-line arguments
- Custom providers, installed or created
- Directory files
- In-memory objects

This is JSON file example, containing Logging configuration as key-value paris. This can be loaded using `.AddJsonFile(...)` during app start.

```Json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
    }
  },
}
```
Why do we have so many providers options? 
- Sometimes in development we just want to load all the variables from one file. And we want to easily switch between different environments.
- In large distributed systems, we want to have a central shop for multiple services.
- For secrecy, we need a process that manages the use of these variables to protect the content. This can be done with Azure Secrets Storage, for example, where the protected value is written by an Azure process to environment variables where the secret is stored when the app is deployed.
- Testing reasons and environment, etc.

## Enviroment

`NetCore` configures the behaviour of the app based on the runtime environment using an environment variable.

You can use `IHostingEnvironment` to programmatically set the current environment to have environment-specific behaviour.

This is done by the default builder:

>`CreateDefaultBuilder` creates [WebHostBuilder](https://github.com/dotnet/aspnetcore/blob/d8bba727bdfaa3abf196c7f7c476966ed4af6692/src/DefaultBuilder/src/WebHost.cs#L156) object.
> 
>>  ```c#
>>   public static IWebHostBuilder CreateDefaultBuilder(string[] args){
>>      var builder = new WebHostBuilder(); // <--- This
>>      // etc...
>>  ```
> By initializing object [new WebHostBuilder()](https://github.com/dotnet/aspnetcore/blob/main/src/Hosting/Hosting/src/WebHostBuilder.cs) 
> 
>> ```c#
>>  public WebHostBuilder(){
>>      _hostingEnvironment = new HostingEnvironment(); // <--- This
>>      // etc...
>>  ```
>
>1) The private `new HostingEnvironment()` object [is created](https://github.com/dotnet/aspnetcore/blob/4cbce2fda399775daed8641fa36955db0a97a09b/src/Hosting/Hosting/src/Internal/HostingEnvironment.cs#L9). It holds builder `EnvironmentName`. By default it is `Production`. **This is code default** value and depending on start and other configuration can be overwritten on startup to other values as for example `development`.
>>```c#
>>internal class HostingEnvironment : IHostingEnvironment, Extensions.Hosting.IHostingEnvironment, IWebHostEnvironment{
>>      public string EnvironmentName { get; set; } = Extensions.Hosting.Environments.Production; // <--- This
>>      // etc...
>>```
>2) Default enviroment variables with prefix `ASPNETCORE_` are [loaded to configuration](https://github.com/dotnet/aspnetcore/blob/e6afd501caf0fc5d64b6f3fd47584af6f7adba43/src/Hosting/Hosting/src/WebHostBuilder.cs#L45) if they exist.
>>```c#
>>_config = new ConfigurationBuilder()
>>    .AddEnvironmentVariables(prefix: "ASPNETCORE_") // <--- This
>>    .Build();
>>```
>-  If `eviroment` variable exist settings overide code defaults..

Enviroment can be set from various sources:
- Reads directly from system enviroment variable `ASPNETCORE_ENVIRONMENT` if exist.
- Looks if any start `args` was privided and if contains specific Key, it override value from system environment (`ASPNETCORE_ENVIRONMENT`)
- `launchSettings.json` is used in case section (key) `environmentVariables` was povided, then it override value from system environment (`ASPNETCORE_ENVIRONMENT`).
- Code default - if no other source was found (`Production`)

`launchSettings.json` is used by default by VisualStudio, Rider or by running your app from command line using `dotnet cli` etc.. Some editors create custom lunch files like VSCode (when you wanna  run app using its debugger). It will create custom `launch.json` under folder `.vscode`. It does similar think. You can find more info in [VsCode Docs](https://code.visualstudio.com/docs/editor/debugging).

The `launchSettings.json`
- Is only used on development
- Is not deployed.

#### Current enviroment

When you run app with logging enabled, you will see in one of the first logs the current enviroment name.

```Shell
info: Microsoft.Hosting.Lifetime[0]
      Now listening on: https://localhost:5001
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
```

> **WARNING**: The app's environment can't be changed while the app is running.

In runtime you can use `IWebHostEnvironment` to get DI enviroment provider object. By including extension `using Microsoft.Extensions.Hosting;` in your namespace definition , you can easy conditionaly check for enviroment value in rutime.

```c#
// env as IWebHostEnvironment injected by DI
if (env.IsDevelopment()){ ... }
else if(env.IsProduction){ ... }
else if(env.IsStaging){ ... }
```

## AppSettings

`appsettings.json` and `appsettings.development.json` was generated by template and provides settings that aplication loads by [default](https://github.com/dotnet/aspnetcore/blob/4cbce2fda399775daed8641fa36955db0a97a09b/src/DefaultBuilder/src/WebHost.cs#L173).
>
>```c#
>config.AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
>    .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true, reloadOnChange: true);
>```

The `appsettings.json` contains basic common settings. `appsettings.development.json` may contain developer specific settings like different connection strings or some settings / variables.

`reloadOnChange:true` means that the app will monitor the changes in the file and reload the configuration in case of an update without restarting the server.

The generated `appsettings.json` and `appsettings.development.json` contain the default configuration for logging. And the CORS AllowedHost variable.

`*` means that the server accepts requests from any origin. This value can be overridden in the custom configuration introduced laiter.

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
```

You can run the app and change the log level from `"Microsoft": "Warning",` to `"Microsoft": "Information"`. Since both `appsettings.json` and `appsettings.development.json` contain the logging configuration, the value is first taken from `appsettings.json` and then overwritten in `appsettings.development.json`. So depending on your current environment, the value will be applied at runtime. If you are in the development environment, you will need to change the value in `appsettings.development.json`. Note that if you delete the entire logging configuration from `appsettings.development.json`, the value from `appsettings.json` will be used because it will no longer be overwritten.

> **INFO**: Settings files are used in same time just in case they have equal propertis inside it, this propertis gets override by each other in app configuration.

## Startup.cs

This class is used by `ConfigureWebHostDefaults` from `Program.cs` on app init and contains 2 methods:
1) `ConfigureServices` - IoC (DI) container servcie registration (call order does not metter)

    ```c#
    public void ConfigureServices(IServiceCollection services) {
        //services.AddControllers();
        services.AddSwaggerGen(c => {
            c.SwaggerDoc("v1", new OpenApiInfo { Title = "API", Version = "v1" });
        });
    }
    ```
2) `Configure` - Http Request pipeline setup (call order metters) This is how your request goes through app.

    ```c#
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env) {
        // Order of call sets request pipe order !
        if (env.IsDevelopment()) {
            app.UseDeveloperExceptionPage();
            app.UseSwagger();
            app.UseSwaggerUI(c => c.SwaggerEndpoint("/swagger/v1/swagger.json", "API v1"));
        }
        app.UseHttpsRedirection();
        app.UseRouting();
        app.UseAuthorization();
        app.UseEndpoints(endpoints => {
            endpoints.MapControllers();
        });
    }
    ```

You can read about app `Startup.cs` more [under oficial doc](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-5.0).

## ConfigureServices 

The ConfigureServices method:

- Is Optional.
- Called by the host before the `Configure` method to register all DI services.

By default it register OpenAPI (Swagger) service. (Expecting the app was ceated from API tempale)

```
services.AddSwaggerGen(c => {
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "API", Version = "v1" });
});
```

`ConfigureServices` can contain a lot of lines of code in a real application. Best to remember whenever there are more than 3 lines or the registry is contextual (authorization, file server, etc) and group them in a separate extension for `IServiceCollection`.

As an example, let us show a more complex Swagger configuration. This can make the `Programme.cs` very large and hard to read. In this example, it is better to move these Swagger-related things into a separate extension that allows us to simply call `services.AddSwagger()` and hide all the details in a separate file.

```
public static partial class ServiceExtension {
    public static IServiceCollection AddSwagger(
        this IServiceCollection serviceCollection) {
        serviceCollection.AddSwaggerGen(
            e => {

                e.SwaggerDoc("v1", new OpenApiInfo { Title = "My API", Version = "v1" });
                e.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme {
                    Description = "JWT Authorization header is using the Bearer scheme. \r\n\r\n Example: \"Bearer {key}\"",
                    Name = "Authorization",
                    In = ParameterLocation.Header,
                    Type = SecuritySchemeType.ApiKey,
                    Scheme = "Bearer"
                });
                e.AddSecurityRequirement(new OpenApiSecurityRequirement()
                {
                {
                    new OpenApiSecurityScheme
                    {
                        Reference = new OpenApiReference
                        {
                            Type = ReferenceType.SecurityScheme,
                            Id = "Bearer"
                        },
                        Scheme = "oauth2",
                        Name = "Bearer",
                        In = ParameterLocation.Header,

                    },
                    new List<string>()
                }
            });
            });

        return serviceCollection;
    }
}
```

#### Swagger

[Swagger](swagger.io) is opensource framework used to make design, implementation and documentation of API much simpler. The specification itself is called [OpenAPI](https://swagger.io/docs/specification/about/) (previously Swagger Specification) it is Interface Description Language for describing RESTful APIs.

**Helps with:**
- Developing - Automatic generation of OpenAPI.
- Documenting - Self documenting. Can use comments from code and merge it with generated documenation based on your code.
- Interaction - Swagger UI provides easy way to test your API.
- Tooling - Swager editor, Swagger generator

> **INFO**: An OpenAPI file allows you to describe your entire API include:
>- Available endpoints (/users) and operations on each endpoint (GET /users, POST /users)
>- Operation parameters Input and output for each operation
>- Authentication methods
>- Contact information, license, terms of use and other information..

This generated file usualy served as JSON is laiter loaded by SwaggerUI which transform this specification to human interactiv API documenattion.

If two companies works on som interface between thier systems, both can use OpenAPi to describe each side interface. Today moder code-geerators are able to fully generate client based on this specification.

This demo will use swagger to test some fuctionality.

## Configure (Middleware)

Middleware is code that's added in pipeline to handle requests and responses. The function call order is important since it sets the request order over system.

```
public void Configure(IApplicationBuilder app, IWebHostEnvironment env) {
    if (env.IsDevelopment()) {
        app.UseDeveloperExceptionPage();
        app.UseSwagger();
        app.UseSwaggerUI(c => c.SwaggerEndpoint("/swagger/v1/swagger.json", "API v1"));
    }
    app.UseHttpsRedirection();
    app.UseRouting();
    app.UseAuthorization();
    app.UseEndpoints(endpoints =>{
        endpoints.MapControllers();
    });
}
```

Each Middleware:

- Chooses whether to pass the request to the next middleware in pipeline.
- Can perform work before and after the next component in the pipeline.

Using this you can inject custom code on any position in request or response and return for example error in case request contains some value or exception happend on response.

![Pipeline example](./Assets/DefaultPipeline.png "Pipeline example")

As it is displayed on drawing (and code) some middlewares are applyed conditionaly only on `development` enviroment.

`app.UseDeveloperExceptionPage()` Adds middleware enabling web-server to show exception detail in case of error. By default this is disabled from security reasons. Imagine this as function wrapping code to `try{}catch{}` and in case of exception it returns simple html with exception message. This is what this middleware do.
`app.UseSwagger()` Adds middleware allowing us to access and download generated OpenAPI on specific URL. This is part of Swagger Library.
`app.UseSwaggerUI(...) `Adds middleware allowing us to browse and test generated API documentation. Its running under specific url.
`UseHttpsRedirection()` - Foce server to use HTTPS and autoredirect from HTTP protocol.
`UseRouting))` - Adds route matching to the middleware pipeline. This middleware looks at the set of endpoints defined in the app, and selects the best match based on the request. (Matches request to an endpoint)
`UseEndpoints(...)` - Adds endpoint execution to the middleware pipeline. It runs the delegate associated with the selected endpoint. (Execute the matched endpoint)

**Impornatnt notes:**

- If the app calls `UseStaticFiles`, place `UseStaticFiles` before UseRouting.
- t's important that you place the `Authentication` and `Authorization` middleware between UseRouting and UseEndPoints .
- Any middleware that appears after the `UseRouting()` call will know which endpoint will run eventually. Any middleware that appears before the `UseRouting()` call won't know which endpoint will run eventually.

## API.csproj

This is project configuration file. It tells .NET how to build the project. It contains project, language, compiler and tooling settings. The content can change between different language versions.

```
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net5.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="5.6.3" />
  </ItemGroup>
</Project>
```

To understand detail you can [read oficial docs](https://docs.microsoft.com/en-us/aspnet/web-forms/overview/deployment/web-deployment-in-the-enterprise/understanding-the-project-file).







